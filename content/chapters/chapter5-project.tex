\chapter{PicnicAuth}

\section{Architektura projektu}
Projekt składa się z trzech komponentów: serwera w architekturze REST (Representational state transfer) API, 
informacyjnej strony internetowej oraz bibliotek klienckich. Komponenty te są od siebie niezależne, dzięki czemu 
łatwa jest rozbudowa projektu, jak również wersjonowanie każdego z nich.

\subsection{REST API}
Pierwszym z nich jest serwer implementujący logikę aplikacji. 
Jest on stworzony w technologii \textit{ASP.NET Web API 2} w języku programowania \textit{C\#}. \\
Przy jego tworzeniu zostały zachowane zasady architektury REST, co pozwala na łatwą i sprawną integracją
platform klienckim, niezależnie od użytej technologii. \\ \\
Zasoby udostępniane przez REST API to:
\begin{itemize}
	\item \textit{[GET] /api/Companies/Me/AuthUsers} \\
		Zwraca listę użytkowników dla aktualnie zalogowanego podmiotu.
	\item \textit{[POST] /api/AuthUsers} \\
		Tworzy nowego użytkownika i dodaje go do kolekcji użytkowników zalogowanego podmiotu.
		W odpowiedzi zwracany jest sekret stworzonego użytkownika, jak również link 
		do kodu QR kompatybilnego z aplikacjami mobilnymi.
	\item \textit{[PATCH] /api/AuthUsers/{userId}/secret} \\
		Generuje nowy sekret dla użytkownika o podanym \textit{userdId}.
	\item \textit{[GET] /api/Companies/Me} \\ 
		Zwraca dane zalogowanego podmiotu, takie jak login, adres poczty elektronicznej oraz unikalny identyfikator.
	\item \textit{[POST] /api/Companies} \\
		Tworzy nowe konto podmiotu. 
	\item \textit{[GET] /api/AuthUsers/{userId}/hotp} \\
		Zwraca hasło jednorazowe typu \textit{HOTP} dla użytkownika o podanym \textit{userId}.
	\item \textit{[GET] /api/AuthUsers/{userId}/totp} \\
		Zwraca hasło jednorazowe typu \textit{TOTP} dla użytkownika o podanym \textit{userId}.
	\item \textit{[GET] /api/AuthUsers/{userId}/hotp/{hotp}} \\
		Zwraca wynik weryfikacji podanego hasła jednorazowego typu \textit{HOTP}
	\item \textit{[GET] /api/AuthUsers/{userId}/totp/{totp}} \\
		Zwraca wynik weryfikacji podanego hasła jednorazowego typu \textit{TOTP}
	\item \textit{[POST] /api/tokens}
		Zwraca klucz API, który służy do uwierzytelnienia podmiotu. (Równoznaczne z logowaniem,
		zgodnym ze standardem \textit{OAuth}.)
\end{itemize}
Zasoby na których operuje API są w formacie JSON (JavaScript Object Notation), zarówno przy metodach, które
przyjmują dane, jak i tych, które zwracają dane. \\
Za pomocą pakietu \textit{Swashbuckle} skonfigurowana została automatyczna generacja dokumentacji API
na podstawie publicznie wystawionych kontrolerów. 
Oprócz podstawowych informacji o metodach znajdujących się w kontrolerach, takich jak nazwy czy typy parametrów, 
w~dokumentacji umieszczane są także komentarze, którymi opisana jest dana metoda. Oprócz funkcji informacyjnej, 
wygenerowana dokumentacja pozwala na wygodne testy każdej z metod. 
Końcowy efekt wygenerowanej dokumentacji przedstawiony jest na Rysunku \ref{swagger}. \\
Aplikacja przeznaczona jest do działania na serwerze \textit{IIS (Internet Information Service)} w~wersji~8.5.
\begin{figure}[t]
    \centering
	\includegraphics[width=\textwidth]{content/images/swagger}
    \caption{Interaktywna dokumentacja API.}
    \label{swagger}
\end{figure}

\subsection{Frontend}
Strona internetowa projektu (Rysunek \ref{front-home}) stworzona została w technologii \textit{Angular} w wersji~5 w konwencji 
\textit{Single Page Application}. Znajduje się na niej instrukcja użycie projektu jak również informacje
o aktualnej liczbie dostępnych bibliotek. Zawiera ona także przydatne odnośniki do repozytoriów, w których
znajduje się kod źródłowy oraz do strony na której znajduje się dokumentacja API. \\
Dodatkowymi funkcjonalnościami jakie oferuje strona jest stworzenie nowego konta dla podmiotu 
(przedstawione na Rysunku \ref{front-create}), jak również uzyskanie klucza API, 
umożliwiającego użycie bibliotek klienckich.
\begin{figure}[t]
    \centering
	\includegraphics[width=\textwidth]{content/images/front-home}
    \caption{Informacyjna strona internetowa projektu.}
    \label{front-home}
\end{figure}
\begin{figure}[t]
    \centering
	\includegraphics[width=\textwidth]{content/images/front-create}
    \caption{Tworzenie konta podmiotu.}
    \label{front-create}
\end{figure}

\subsection{Biblioteki klienckie}
W celu ułatwienia integracji z serwerem zaimplementowane zostały biblioteki klienckie.
Umożliwiają one w prosty sposób użycie funkcjonalności serwera bez konieczności 
studiowania dokumentacji i pisania kodu odpowiedzialnego za integrację. \\
Przykładowo biblioteka w języku C\# udostępnia klasę \textit{PicnicAuthClient}, posiadająca metody:
\begin{itemize}
	\item Login
	\item GetAuthUsers
	\item AddAuthUser
	\item GenereteNewSecret
	\item GetLoggedCompany
	\item AddCompany
	\item GetHotpForAuthUser
	\item ValidateHotpForAuthUser
	\item GetTotpForAuthUser
	\item ValidateTotpForAuthUser
\end{itemize}
Na chwilę obecną gotowe do użycia są biblioteki w następujących technologiach:
\begin{enumerate}
	\item C\#
	\item Visual Basic
	\item TypeScript
	\item Python 3.6
	\item Python 2.7
	\item Ruby
\end{enumerate}

\section{Tworzenie konta podmiotu}
Podmiotem jest nazywana instytucja, posiadająca użytkowników i chcąca wykorzystać w~swoim systemie 
uwierzytelnienie dwuetapowe. \\
Podmiot jest opisany bazodanowym modelem \textit{CompanyAccount}, bazującym na klasie \textit{IdentityUser}
z przestrzeni \textit{Microsoft.AspNet.Identity}.
Oprócz standardowych pól odziedziczonych z klasy \textit{IdentityUser}, model ten posiada także kolekcję 
kolekcję użytkowników \textit{AuthUser}. \\
Sam proces tworzenia nowego konta jak i autoryzacji jest zgodny ze standardowym zarządzeniem zwykłymi użytkownikami
w projekcie typu \textit{WebAPI} w technologii \textit{.Net}. \\
W~celu stworzenia nowego konta, metodą \textit{HTTP POST}, na adres \mbox{/api/Companies}, wysyłane są dane konta, 
takie jak adres poczty elektronicznej, nazwa konta oraz hasło. 
Format wysyłanych danych w postaci obiektu JSON jest przedstawiony poniżej:
\begin{lstlisting}
{
  "Email": "string",
  "UserName": "string",
  "Password": "string",
  "ConfirmPassword": "string"
}
\end{lstlisting}
Proces logowania również jest standardowy i zgodny ze standardem \textit{OAuth}.
Na adres \textit{/api/tokens}, metodą \textit{POST} wysyłane są dane takie jak nazwa konta oraz hasło
a w odpowiedzi zwracany jest token typu JWT (JSON Web Token), wykorzystywany do autoryzacji podmiotu.
Otrzymany token jest wysyłany przy każdym kolejnym zapytaniu w nagłówku w postaci \textit{Authorization: Bearer \{JWT\}}.

\section{Generacja sekretu użytkownika}
Po utworzeniu konta podmiotu możliwe jest dodanie do kolekcji użytkowników nowego użytkownika. 
Wysyłane jest wtedy zapytanie typu \textit{POST} na adres \textit{/api/AuthUsers}. Zasób pod tym adresem dostępny jest 
wyłącznie po zalogowaniu się kontem podmiotu. \\
Dane mają postać obiektu:
\begin{lstlisting}
{
  "ExternalId": "string",
  "UserName": "string",
  "Email": "string"
}
\end{lstlisting}
Po przesłaniu żądania tworzone jest konto użytkownika a następnie zapisywane jest ono do bazy. 
W procesie tym ważnym etapem jest generacja sekretu użytkownika. \\ 
Do tego celu stworzona została klasa \textit{SecureRandomNumberGenerator}, której kod widoczny jest na Rysunku \ref{code-srng}.
Wykorzystywana jest w niej klasa \textit{RNGCryptoServiceProvider} z przestrzeni \textit{System.Security.Cryptography}.
Stworzona klasa wykorzystywana jest do wygenerowania kryptograficznie bezpiecznego, pseudolosowego ciągu bajtów, zwracanego 
w formie tablicy.
\begin{figure}[t]
    \centering
	\includegraphics[width=\textwidth]{content/images/code-srng}
    \caption{Klasa zwracająca kryptograficznie bezpiecznie pseudolosowe dane.}
    \label{code-srng}
\end{figure} \\
Bardziej wyspecjalizowaną klasą jest klasa \textit{SecretGenerator}, przedstawiona na Rysunku \ref{code-secretgenerator}.
Jest w niej użyta funkcjonalność poprzedniej klasy. Zwraca ona wygenerowany sekret użytkownika, czyli ciąg bajtów o długości
zgodnej z zaleceniami standardu, równej dziesięć.
\begin{figure}[t]
    \centering
	\includegraphics[width=\textwidth]{content/images/code-secretgenerator}
    \caption{Klasa generująca sekret użytkownika.}
    \label{code-secretgenerator}
\end{figure}

\section{Dostarczanie sekretu na urządzenie mobilne}
Po wysłaniu danych do stworzenia użytkownika w odpowiedzi wysyłany jest obiekt reprezentujący
nowo stworzonego użytkownika:
\begin{lstlisting}
{
  "ExternalId": "string",
  "UserName": "string",
  "Email": "string",
  "HotpQrCodeUri": "string",
  "TotpQrCodeUri": "string",
  "SecretInBase32": "string",
  "Id": "00000000-0000-0000-0000-000000000000"
}
\end{lstlisting}

\begin{figure}[t]
    \centering
	\includegraphics[width=\textwidth]{content/images/code-keyuri}
    \caption{Klasa generująca KeyUri.}
    \label{code-keyuri}
\end{figure}
\begin{figure}[t]
    \centering
	\includegraphics[width=0.5\textwidth]{content/images/qr-hotp}
    \caption{Kod QR umożliwiający generację haseł typu HOTP.}
    \label{qr-hotp}
\end{figure}
\begin{figure}[t]
    \centering
	\includegraphics[width=0.5\textwidth]{content/images/qr-totp}
	\caption{Kod QR umożliwiający generację haseł typu HOTP.}
    \label{qr-totp}
\end{figure}

\section{Generowanie OTP po stronie serwera}
\begin{figure}[t]
    \centering
	\includegraphics[width=\textwidth]{content/images/code-hmac}
    \caption{Klasa generująca HMAC.}
    \label{code-hmac}
\end{figure}
\begin{figure}[t]
    \centering
	\includegraphics[width=\textwidth]{content/images/code-truncator}
    \caption{Klasa odpowiedzialna za przycięcie wyniku HMAC do postaci hasła.}
    \label{code-truncator}
\end{figure}
\begin{figure}[t]
    \centering
	\includegraphics[width=\textwidth]{content/images/code-hotpgenerator}
    \caption{Klasa generująca hasło jednorazowe oparte o licznik.}
    \label{code-hotp}
\end{figure}
\begin{figure}[t]
    \centering
	\includegraphics[width=\textwidth]{content/images/code-totpgenerator}
    \caption{Klasa generująca hasło jednorazowe oparte o czas.}
    \label{code-totp}
\end{figure}

\section{Generowanie OTP po stronie użytkownika}
\begin{figure}[t]
    \centering
	\includegraphics[width=0.5\textwidth]{content/images/mobile-google}
	\caption{Użycie aplikacji Google Authenticator.}
    \label{mobile-google}
\end{figure}
\begin{figure}[t]
    \centering
	\includegraphics[width=0.5\textwidth]{content/images/mobile-authy}
	\caption{Użycie aplikacji Authy.}
    \label{mobile-authy}
\end{figure}

\section{Przechowywanie sekretu użytkownika}
\begin{figure}[t]
    \centering
	\includegraphics[width=\textwidth]{content/images/code-encrypt}
    \caption{Klasa odpowiedzialna za szyfrowanie.}
    \label{code-encrypt}
\end{figure}
\begin{figure}[t]
    \centering
	\includegraphics[width=\textwidth]{content/images/code-decrypt}
    \caption{Klasa odpowiedzialna za deszyfrowanie.}
    \label{code-decrypt}
\end{figure}

\section{Walidacja hasła jednorazowego}
\begin{figure}[t]
    \centering
	\includegraphics[width=\textwidth]{content/images/code-tvalidator}
    \caption{Klasa odpowiedzialna za walidację hasła typu TOTP.}
    \label{totp-validator}
\end{figure}

\section{Przykład użycia projektu}

\section{Planowane ulepszenia}

\subsection{Generowanie hasła po stronie użytkownika}
Za najbezpieczniejsza metodę generacji haseł jednorazowych po stronie użytkownika uważany jest 
token sprzętowy, zabezpieczony kodem PIN. 
Jest to dosyć kosztowna metoda ze względu na koszty produkcji takiego tokenu, jak również 
jest mało uniwersalna, gdyż zwykle token powiązany jest z pojedynczym kontem. \\
Wychodząc na przeciw tym ograniczeniom, mogą tutaj zostać zaproponowane rozwiązania 
oparte o mikrokontroler \textit{Arduino Uno} lub o mini-komputer \textit{Raspberry Pi Zero}.
Projekt ten mógłby mieć formę DIY (Do it yourself) czyli być przepisem jak z dostarczonego 
oprogramowania i części stworzyć własny token sprzętowy, mogący generować hasła jednorazowe do wielu serwisów. 
Token posiadałby ekran, na którym wyświetlane by było wygenerowane hasło jedno razowe oraz klawiaturę 
alfanumeryczną, wykorzystywaną do podawania kodu PIN oraz do dodania nowego konta do bazy tokenu.

\subsection{Biblioteki klienckie}
Użycie REST API jest możliwe w każdej technologii umożliwiającej wykorzystanie protokołu HTTP 
wraz z formatem JSON. 
Dużo wygodniejsze jest jednak korzystanie z gotowych bibliotek, stworzonych pod daną technologię. \\ \\
W tym celu, w kolejnych wersjach projektu, planowana jest implementacja bibliotek klienckich w następujących 
językach programowania:
\begin{itemize}
	\item{C}
	\item{C++}
	\item{Clojure}
	\item{D}
	\item{Elixir}
	\item{Erlang}
	\item{Groovy}
	\item{Java}
	\item{JavaScript}
	\item{Kotlin}
	\item{Nim}
	\item{Objective-C}
	\item{Perl}
	\item{PHP}
	\item{Scala}
	\item{Swift}
\end{itemize}

\subsection{Architektura}
Możliwe jest także ulepszenie architektury części REST API projektu pod kątem większego odseparowania od siebie komponentów.
Szczególnie dotyczy to odseparowania części przechowującej sekrety użytkowników i walidującej hasła jednorazowe od reszty
aplikacji. 
W~idealnym przypadku odseparowana część umieszczona by była na osobnym systemie komputerowym, bez dostępu do Internetu. 
Komunikacja z główną częścią aplikacji powinna odbywać się wtedy poprzez minimalny interfejs, pozwalający wyłącznie na 
uwierzytelnienie podmiotu oraz walidację podanego przez użytkownika hasła jednorazowego. 
Po przesłaniu podanego przez użytkownika hasła jednorazowego, 
zwrócony zostałby jedynie wynik walidacji w postaci \textit{true} lub \textit{false}.

\subsection{Konteneryzacja części serwerowej}
Poza podstawowym przypadkiem użycia opartym o REST API wystawione pod adresem \texttt{https://picnicauth.gear.host/swagger/ui/index},
nic nie stoi na przeszkodzie wykorzystaniu kodu źródłowego aplikacji i stworzenia REST API na własnym serwerze, na przykład w firmowej
sieci lokalnej. Ten sposób wykorzystania projektu może okazać się bardziej bezpieczny, jeśli jest przez dany podmiot 
umiejętnie administrowany oraz zupełnie niebezpieczny w przeciwnym przypadku. \\
Aby ułatwić procedurę wdrożenia REST API na serwer można zaproponować tutaj użycie kontenerów. 
Dzięki nim aplikacja nie jest zależna od systemu, który jest zainstalowany na serwerze a sam proces wdrożenia jej
jest niezwykle prosty i szybki.
Może zostać użyte oprogramowanie \textit{Docker}. 

\subsection{Przechowywanie sekretu}
Obecnie do szyfrowania sekretów użytkowników wykorzystywany jest interfejs \textit{Windows Data Protection}. 
Posiada on kilka wad, między innymi to, że jest silnie zależny od hasła użytkownika sytemu. 
Lepszym ale i bardziej kosztownym rozwiązaniem, byłoby użycie szyfrowania sprzętowego zamiast wspomnianego interfejsu.
