\chapter{Kryptografia w praktyce}

\section{Pojęcia pomocnicze}
Przed przystąpieniem do opisu praktycznych aspektów kryptografii użytych w projekcie, wymagane jest 
wyjaśnienie pojęć wykorzystywanych w mechanizmie haseł jednorazowych, lecz które nie są bezpośrednio 
związane z kryptografią. 

\subsection{Kodowanie transportowe}
Kodowanie transportowe wykorzystywane jest w przypadku, gdy zachodzi potrzeba transferu danych
w środowiskach, które pozwalają na przesyłanie wyłącznie znaków ASCII. \\ \\
Użycie kodowania transportowego jest konieczne w celu zachowania kompatybilności przy pracy z protokołami, 
które przystosowane są do pracy na danych 7-bitowych. W takim przypadku najstarszy bit jest zerowany, co
mogłoby uszkodzić przesyłane dane. W przypadku przesyłania wyłącznie znaków ASCII zerowanie najstarszego bitu
nie jest problemem, gdyż wszystkie znaki w podstawowej tablicy ASCII mają ten bit wyzerowany.\\
Bardziej współczesnym przykładem wykorzystania kodowania transportowego jest osadzanie danych graficznych bezpośrednio w kodzie HTML. Konieczne jest wówczas zakodowanie danych w celu wyeliminowania ryzyka pojawienia się znaków '<' oraz '>', które mogłyby być zinterpretowane jako tagi HTML. \\ \\
Aby ujednolicić implementacje kodowania transportowego został stworzony dokument RFC 4648 \cite{encoding}, w którym opisany jest prawidłowy sposób implementacji oraz to jaki typ kodowania wybrać w zależności od nałożonych wymagań.

\subsubsection{Kodowanie Base64}
Najczęściej spotykanym typem kodowania transportowego jest kodowanie Base64. Kodowanie to konwertuje dowolny ciąg bajtów do postaci ciągu złożonego z małych i wielkich liter, cyfr oraz znaków '+' i '/'. 
Jeżeli po zakodowaniu końcowa część danych jest mniejsza niż 24 bity używany jest także znak '=' jako dopełnienie. \\
Sam proces kodowania polega na pobraniu 24 bitów danych a następnie podzieleniu ich na 4 grupy po 6 bitów. Każda z grup jest interpretowana jako indeks tablicy ustalonego alfabetu Base64.
Dla każdej z grup za pomocą indeksu odczytywany jest znak a następnie dopisywany jest on do ciągu zakodowanego. \\
Istnieje również odmiana kodowania Base64 przystosowana do użycia w przypadku adresów URL czy nazw plików.
W alternatywie tej zamiast znaków '+', '/', które mogłyby zostać błędnie zinterpretowane np w środowisku systemu plików,
używane są znaki '-' oraz '\_'.

\subsubsection{Kodowanie Base32}
W porównaniu do kodowania Base64, dane zakodowane w Base32 są dużo bardziej czytelne dla ludzi.
Właściwość ta spowodowana jest faktem, że w kodowaniu Base32 nie ma znaczenia wielkość liter, dzięki czemu przykładowo
nie ma problemu z rozróżnieniem małej litery 'L' z wielką literą 'I' ('l' oraz 'I'). \\
Alfabet kodowania Base32 składa się z 32 znaków ASCII oraz znaku '=' pełniącego funkcje dopełnienia.
Proces kodowania polega na pobraniu 40 bitów danych a następnie ustawienie ich w osiem 5-bitowych grup. 
Każda z 8 grup interpretowana jest jako jeden ze znaków alfabetu Base32. \\
Podobnie jak przy kodowaniu Base64, wymagane jest tutaj wstawienie dopełnienia w sytuacji, gdy długość ostatniej z grup jest mniejsza od 40 bitów.

\begin{table}[h!]
\centering
\caption{Alfabet w kodowaniu Base32}
\begin{tabular}{ |c c|c c|c c|c c| } 
 \hline
 Indeks & Znak & Indeks & Znak & Indeks & Znak & Indeks & Znak \\ 
 \hline
 0 & A & 9  & J & 18 & S & 27 & 3 \\ 
 1 & B & 10 & K & 19 & T & 28 & 4 \\ 
 2 & C & 11 & L & 20 & U & 29 & 5 \\ 
 3 & D & 12 & M & 21 & V & 30 & 6 \\ 
 4 & E & 13 & N & 22 & W & 31 & 7 \\ 
 5 & F & 14 & O & 23 & X &    &   \\ 
 6 & G & 15 & P & 24 & Y &    &   \\  
 7 & H & 16 & Q & 25 & Z &    &   \\ 
 8 & I & 17 & R & 26 & 2 &    &   \\ 
 \hline
\end{tabular}
\end{table}

\subsection{Czas uniksowy}
Czas uniksowy jest sposobem na reprezentację punktu w czasie, polegającym na mierzeniu sekund, które
upłynęły od daty 1 stycznia 1970 (UTC). W systemach uniksowych zwykle reprezentowany jest w postaci
32-bitowej liczby całkowitej ze znakiem. \\
W przypadku architektur typu serwer-klient wskazane jest synchronizowanie czasu wykorzystując czas~uniksowy,
gdyż nie zależy on od lokalizacji w której jest mierzony. Właściwość ta eliminuje problem synchronizacji 
czasu pomiędzy strefami czasowymi.

\subsection{Ujednolicony identyfikator zasobów}
Ujednolicony identyfikator zasobów (ang. Uniform Resource Identifier, URI) jest ciągiem znaków jednoznacznie identyfikującym dany zasób. \\
Składnia identyfikatora jest wyrażana następująco: \\
\centerline{schemat ":" ścieżka ["?" zapytanie] ["\#" fragment]} 
Warto zauważyć, że składnia ta determinuje schemat (protokół), jaki wykorzystywany jest przy interakcji z identyfikowanym zasobem. \\

Przykłady identyfikatorów:
\begin{itemize}
	\item ftp://randomftp.com/files/file.docx
	\item https://www.randomwebsite.pl/index.html
	\item mailto:jan.nowak@wp.pl
	\item tel:+48-25-123-88
\end{itemize}

Szczegóły dotyczące standardu URI są opisane w dokumencie RFC~3986 \cite{uri}. 

 
\section{Hasło jednorazowe}
Hasło jednorazowe jest jedną z możliwych form uwierzytelnienia przy używaniu uwierzytelnienia wieloetapowego. \\
W odróżnieniu od zwykłego, statycznego hasła, haseł jednorazowych można użyć tylko raz. 
Dzięki czemu przechwycenie przez atakującego, raz użytego hasła, nie daje możliwości uwierzytelnienia. \\
Hasła jednorazowe eliminują również problem zbyt niskiej entropii w hasłach. 
Często zdarza się, że hasła tworzone przez użytkowników są zbyt słabe, przez co nie zapewniają wystarczającego
poziomu bezpieczeństwa. Hasła jednorazowe powstają przy użyciu bezpiecznych generatorów liczb pseudolosowych, 
dzięki czemu zapewniony jest wystarczający poziom entropii (pod warunkiem, że generatory te są w odpowiedni 
sposób używane). \\ \\
Istnieje wiele metod generacji haseł jednorazowych o różnym stopniu bezpieczeństwa. 
Niektóre z tych metod to:
\begin{enumerate}
	\item Użycie łańcucha wyników funkcji skrótu.
	\item Użycie mechanizmu HMAC w połączeniu z synchronizowanym licznikiem.
	\item Użycie mechanizmu HMAC z synchronizacją czasu.
\end{enumerate}
Standard uwierzytelniania za pomocą haseł jednorazowych zdefiniowany jest w dokumencie \textit{RFC 2289} \cite{otprfc}.

\subsection{Hasło oparte o HMAC}
Do generacji haseł tego typu wykorzystywana jest funkcja HMAC. Może być tu użyta dowolna funkcja skrótu, jednak 
musi być ona taka sama po stronie generującej jak i weryfikującej. 
Na wejście funkcji podawane są dwa argumenty, symetryczny klucz oraz licznik. 
Konieczne jest aby obie wartości były zsynchronizowane pomiędzy użytkownikiem a stroną uwierzytelniającą. 
Przy każdej udanej walidacji hasła jednorazowego licznik zwiększany jest o 1. \\
Przykładowo używając funkcji skrótu SHA-1, wynik HMAC-SHA-1 o długości 160 bitów jest obcinany do kilku znakowego hasła. 
Hasło powinno być używane w postaci numerycznej a za minimalną bezpieczną długość hasła uznawane jest sześć cyfr.
Minimalną długością klucza kryptograficznego jest 128 bitów, rekomendowane jest jednak używanie przynajmniej 160-bitowego 
klucza. \\ \\
Proces generacji hasła jednorazowego można przedstawić następująco: \\
$$HOTP(K, C) = Przytnij(\hmac(K, C))$$
Przycięcie przebiega w dwóch etapach. W pierwszym etapie 160-bitowy wynik funkcji HMAC skracany jest do czterech bajtów.
Z 160 bitów pobierane są 4 ostatnie bity. 
Wykorzystywane są one jako indeks, od którego pobieramy 4 bajty z wyniku funkcji HMAC.
Drugi etap polega na obliczeniu reszty z dzielenia z poprzedniego wyniku przez $10^n$, gdzie \textit{n} jest 
liczbą cyfr jaką chcemy ostatecznie otrzymać. \\
Algorytm jak i przykładowa implementacja w języku \textit{Java} znajduje się w dokumencie \textit{RFC~4226}~\cite{hotprfc}.

\subsection{Hasło oparte o czas}
\subsection{Porównanie HOTP i TOTP}
\subsection{Porównanie kanałów dostarczania}

\section{Interfejs Windows Data Protection}
